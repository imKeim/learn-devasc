<!-- 3.1.1 -->
## Введение

Процесс разработки программного обеспечения также известен как жизненный цикл разработки программного обеспечения (SDLC). Этот процесс - больше, чем просто кодирование. Он также включает сбор требований, создание доказательства концепции, тестирование и исправление ошибок.

В этом модуле мы обсуждаем фазы жизненного цикла разработки программного обеспечения, а также методологии управления реальными требованиями программных проектов. Обсуждаемые здесь методологии начинаются с каскадной модели, в которой упор делается на предварительное планирование. Другие методологии в этой теме, такие как Agile и Lean, более динамичны и адаптивны, чем каскадная модель.

<!-- 3.1.2 -->
## Жизненный цикл разработки программного обеспечения (SDLC)

![](./assets/3.1.2.png "Жизненный цикл разработки программного обеспечения (SDLC)")
<!-- /courses/devnet/ce497bc0-a786-11ea-aa1c-f915852d4dce/ce4becc0-a786-11ea-aa1c-f915852d4dce/assets/85ba7920-bcbe-11ea-8b68-49335aec753f.svg -->

### Фазы жизненного цикла разработки программного обеспечения

Жизненный цикл разработки программного обеспечения (SDLC) - это процесс разработки программного обеспечения, начиная с идеи и заканчивая доставкой. Этот процесс состоит из шести этапов. На каждом этапе учитываются результаты предыдущего этапа. Стандартного SDLC не существует, поэтому точные этапы могут отличаться, но наиболее распространенными являются:

Этап 1. Анализ требований

Этап 2. Дизайн (проектирование)

Этап 3. Реализация

Этап 4. Тестирование

Этап 5. Развертывание

Этап 6. Обслуживание

Исторически сложилось так, что команды разработчиков обычно следовали этим этапам по порядку в каскадной модели. Целью которой было завершить каждый этап SDLC до мельчайших деталей, прежде чем переходить к следующему, никогда не возвращаясь к предыдущему этапу и записывая все по ходу.

Хотя каскадные методы все еще широко используются сегодня, они постепенно вытесняются более адаптивными и гибкими методами, которые позволяют создавать лучшее программное обеспечение, быстрее и с меньшими трудностями. Эти методы известны под общим названием «Гибкая разработка».

Важно понимать, что SDLC можно применять разными способами. Его фазы могут повторяться, а порядок может изменяться на противоположный. Отдельные этапы могут выполняться на многих уровнях параллельно (например, требования могут быть собраны отдельно по деталям пользовательского интерфейса, внутренней интеграции, параметрам работы и производительности и т. д.).

Мы рассмотрим этапы SDLC более подробно и в их классическом порядке (просто помните: это описание, а не рецепт).

<!-- 3.1.3 -->
## Этап требований и анализа

Цель этапа требований и анализа - ответить на несколько уровней вопросов. Они начинаются с изучения текущей ситуации, потребностей и ограничений заинтересованных сторон, существующей инфраструктуры и т. д. Они определяют, какие проблемы необходимо решить с помощью этого нового программного обеспечения.

После более точного определения проблемы можно изучить более конкретные проблемы, чтобы определить, где и в каком контексте будет использоваться новое программное обеспечение.

Когда ответы на такие вопросы собраны, пора приступить к изучению более точных требований, сосредоточившись на желаемых функциях и пользовательском опыте (UX).

Наконец, команда приступает к оценке архитектурных вариантов для создания самого программного обеспечения. Для большинства корпоративных приложений это означает множество итераций определения требований для внешнего и внутреннего интерфейса программного обеспечения. Вам также потребуется предоставить точки интеграции для других приложений, а также сервисы для управления жизненным циклом.

После сбора требований команда анализирует результаты, чтобы определить следующее:

* Можно ли разработать программное обеспечение в соответствии с этими требованиями и можно ли это сделать в рамках бюджета?
* Есть ли риски для графика разработки, и если да, то каковы они?
* Как будет тестироваться программное обеспечение?
* Когда и как будет доставлено программное обеспечение?
 
По завершении этого этапа классический каскадный метод предлагает создать документ со спецификацией требований к программному обеспечению (SRS), в котором излагаются требования и объем программного обеспечения и тщательно подтверждается этим заинтересованным лицам.

<!-- 3.1.4 -->
## Этап проектирования и реализации

### Проектирование

На этапе проектирования обычно вводится документ SRS из этапа «Требования и анализ». На этапе проектирования архитекторы и разработчики программного обеспечения проектируют программное обеспечение на основе предоставленной SRS.

По завершении этапа проектирования группа создает документы проектирования высокого уровня (HLD) и проектирования низкого уровня (LLD). HLD дает "вид с 10 000 футов" предлагаемого программного обеспечения. Он описывает общую архитектуру, компоненты и их отношения, а также может содержать дополнительные детали. LLD, основанный на документе HLD, гораздо более подробно описывает архитектуру отдельных компонентов, протоколы, используемые для связи между ними, а также перечисляет необходимые классы и другие аспекты проекта.

### Реализация

Этап реализации обычно берет HLD и LLD из этапа проектирования в качестве входных данных.

Этап реализации часто называется этапом кодирования или разработки. На этом этапе разработчики берут проектную документацию и разрабатывают код в соответствии с этим дизайном. Все компоненты и модули создаются на этом этапе, что делает реализацию самой длинной фазой жизненного цикла. На этом этапе инженеры по тестированию также пишут план тестирования.

По завершении этапа внедрения функциональный код, реализующий все требования заказчика, готов к тестированию.

<!-- 3.1.5 -->
## Этапы тестирования, развертывания и обслуживания

### Тестирование

На этапе тестирования обычно вводится программный код этапа реализации. На этом этапе инженеры по тестированию берут код и устанавливают его в среду тестирования, чтобы они могли следовать плану тестирования. План тестирования - это документ, который включает в себя список каждого теста, который необходимо выполнить, чтобы охватить все функции и возможности программного обеспечения в соответствии с требованиями заказчика. Помимо функционального тестирования инженеры-тестировщики также выполняют:

* Интеграционное тестирование
* Тестирование производительности
* Тестирование безопасности

Когда код не проходит тест, инженер-тестировщик определяет ошибку, которая передается разработчикам. После исправления ошибки инженеры-тестировщики повторно протестируют программное обеспечение. Этот обмен между инженерами по тестированию и разработчиками продолжается до тех пор, пока весь код не пройдет все тесты.

По завершении фазы тестирования высококачественная рабочая часть программного обеспечения без ошибок теоретически готова к производству. На практике такое случается редко. Разработчики научились более эффективно тестировать, как встроить тестирование в автоматизированные рабочие процессы и как тестировать программное обеспечение на многих различных уровнях детализации и абстракции: от мельчайших низкоуровневых определений функций до крупномасштабных агрегатов компонентов. Они также узнали, что программное обеспечение никогда не бывает без ошибок, а вместо этого должно быть сделано наблюдаемым, протестированным в производственной среде и отказоустойчивым, чтобы оно могло оставаться доступным и адекватно работать, несмотря на проблемы.

### Развертывание

На этапе развертывания программное обеспечение используется в качестве входных данных. На этапе развертывания программное обеспечение устанавливается в производственную среду. Если проблем с развертыванием нет, менеджер по продукту вместе с архитекторами и квалифицированными инженерами решает, готово ли программное обеспечение к выпуску.

В конце фазы развертывания последняя часть программного обеспечения выпускается для клиентов и других конечных пользователей.

### Обслуживание

На этапе обслуживания команда:

* Обеспечивает поддержку клиентов
* Исправляет ошибки, обнаруженные в производстве
* Работает над улучшением программного обеспечения
* Собирает новые запросы от заказчика

По завершении этапа сопровождения команда готова к работе над следующей итерацией и версией программного обеспечения, которая возвращает процесс к началу SDLC и этапу требований и анализа.

<!-- 3.1.6 -->
## Методологии разработки программного обеспечения

Методология разработки программного обеспечения также известна как модель жизненного цикла разработки программного обеспечения. Эти методологии представляют собой не что иное, как набор правил, шагов, ролей и принципов. Существует много разных методологий, но мы остановимся на трех наиболее популярных:

* Каскадная
* Agile
* Lean

У каждой методики есть свои плюсы и минусы. Решение о том, что использовать, зависит от многих факторов, таких как тип проекта, продолжительность проекта и размер команды.

<!-- 3.1.7 -->
## Каскадная разработка программного обеспечения

![](./assets/3.1.7.png)
<!-- /courses/devnet/ce497bc0-a786-11ea-aa1c-f915852d4dce/ce4becc0-a786-11ea-aa1c-f915852d4dce/assets/85baa030-bcbe-11ea-8b68-49335aec753f.svg -->

Каскад - это традиционная модель разработки программного обеспечения, которая практикуется и по сей день. Каскадная модель почти идентична жизненному циклу разработки программного обеспечения, поскольку каждая фаза зависит от результатов предыдущей фазы.

В водопадах вода течет только в одном направлении. В методе каскада процесс идет в одном направлении и никогда не может идти вспять. Думайте об этом как о эстафете, где один бегун должен закончить свою дистанцию, прежде чем передать эстафету следующему человеку, который его ждет. Палочка всегда движется вперед.

Говорят, что оригинальная каскадная модель была создана Уинстоном У. Ройсом. Его первоначальная модель состояла из семи фаз:

* Системные требования
* Программные требования
* Анализ
* Программное проектирование
* Кодирование
* Тестирование
* Операции

Как видите, каскадная модель - это всего лишь одна итерация жизненного цикла разработки программного обеспечения. Сейчас существует множество вариаций фаз в каскадной модели, но идея о том, что каждая фаза не может перекрываться и должна быть завершена, прежде чем двигаться дальше, остается прежней.

Поскольку результат каждого этапа имеет решающее значение для следующего, одно неверное решение может сорвать всю итерацию; поэтому для большинства реализаций каскадной модели требуется документация, обобщающая результаты каждой фазы, в качестве входных данных для следующей фазы. Если требования изменяются во время текущей итерации, эти новые требования нельзя будет включить до следующей каскадной итерации, что может стать дорогостоящим для крупных программных проектов и вызвать значительные задержки до того, как запрошенные функции станут доступны пользователям.

<!-- 3.1.8 -->
## Гибкая разработка программного обеспечения

Agile-метод гибок и ориентирован на клиента. Хотя методологии, подобные Agile, уже применялись на практике, модель Agile не была официальной до 2001 года, когда семнадцать разработчиков программного обеспечения объединились, чтобы найти решение своего разочарования текущими вариантами, и выступили с Манифестом для гибкой разработки программного обеспечения, также известный как Agile Manifesto.

### Agile Manifesto

Согласно Agile Manifesto, ценности Agile следующие:

* Люди и взаимодействие важнее процессов и инструментов
* Рабочее программное обеспечение важнее исчерпывающей документации
* Сотрудничество с клиентами важнее переговоров по контракту
* Реагирование на изменения важнее следования плану

В манифесте перечислено двенадцать различных принципов:

1.	**Ориентация на клиента** - Нашим высшим приоритетом является удовлетворение потребностей клиентов за счет своевременной и непрерывной поставки ценного программного обеспечения.
2.	**Примите изменения и адаптируйтесь** - Приветствуем меняющиеся требования даже на поздних стадиях разработки. Изменения в гибких процессах используются для конкурентного преимущества клиента.
3.	**Частые поставки рабочего ПО** - Часто доставляйте работающее программное обеспечение, от пары недель до пары месяцев, с предпочтением более коротких сроков.
4.	**Сотрудничество** - Деловые люди и разработчики должны ежедневно работать вместе на протяжении всего проекта.
5.	**Мотивированные команды** - Создавайте проекты вокруг мотивированных людей. Обеспечьте им среду и поддержку, в которых они нуждаются, и доверьте им выполнение работы.
6.	**Личные беседы** - Самый действенный и действенный метод передачи информации команде разработчиков и внутри нее - это личное общение.
7.	**Рабочее программное обеспечение** - Работающее программное обеспечение - это главный показатель прогресса.
8.	**Работайте в устойчивом темпе** - Гибкие процессы способствуют устойчивому развитию. Спонсоры, разработчики и пользователи должны иметь возможность поддерживать постоянный темп бесконечно.
9.	**Гибкая среда** - Постоянное внимание к техническому совершенству и хорошему дизайну повышает маневренность.
10.	**Простота** - Искусство максимизировать объем не сделанной работы - необходимо.
11.	**Самоорганизующиеся команды** - Лучшие архитектуры, требования и проекты создаются самоорганизующимися командами.
12.	**Непрерывное улучшение** - Через регулярные промежутки времени команда размышляет о том, как стать более эффективной, а затем соответствующим образом настраивает и корректирует свое поведение.

<!-- 3.1.9 -->
## Гибкие методы

### Гибкие методы

В «Манифесте Agile» нет точного определения того, как должен работать Agile. После создания Манифеста его создатели (и многие другие) продолжали развивать эти идеи, вбирая новые идеи из многих источников и проверяя их на практике. В результате за последние несколько десятилетий появилось множество подходов к Agile, а некоторые стали широко популярными. Они включают:

* **Agile Scrum** - В регби термин «схватка» описывает момент в игровом процессе, когда игроки собираются вместе и пытаются овладеть мячом. Scrum ориентирован на небольшие самоорганизующиеся команды, которые ежедневно встречаются в течение коротких периодов и работают в итеративных спринтах, постоянно адаптируя результаты для удовлетворения меняющихся требований.
* **Lean** - Основанный на бережливом производстве, метод бережливого производства делает упор на устранение напрасных усилий при планировании и выполнении, а также на снижение когнитивной нагрузки программистов.
* **Экстремальное программирование (XP)** - По сравнению со Scrum, XP более детально описывает передовые методы разработки программного обеспечения и более целенаправленно решает конкретные виды проблем качества жизни, с которыми сталкиваются группы разработчиков программного обеспечения.
* **Разработка на основе функций (FDD)** - FDD предписывает, что разработка программного обеспечения должна осуществляться в рамках общей модели, разбитой, спланированной, спроектированной и построенной по отдельным функциям. Он определяет процесс моделирования, используемый для оценки и планирования предоставления функций, а также подробный набор ролей как для основной группы разработчиков, так и для людей поддержки.

Из описанных выше методологий Agile Scrum, вероятно, является самой популярной. Ниже мы обсудим некоторые термины и концепции Scrum, которые были более или менее повсеместно приняты сообществом Agile во всех методологиях.

### Спринты

В модели Agile по-прежнему применяется жизненный цикл разработки программного обеспечения. В отличие от водопадного метода, где есть одна длинная итерация SDLC, Agile - это множество быстрых итераций SDLC.

Эти быстрые итерации называются спринтами, и цель спринтов - обеспечить частую доставку рабочего программного обеспечения по принципу Agile-манифеста. Спринт - это определенный (ограниченный) период времени, который обычно составляет от двух до четырех недель, но желательно как можно короче. Продолжительность спринта следует определять до начала процесса, и ее следует редко менять.

Во время спринта каждая команда берет на себя столько задач, которые также называются пользовательскими историями, сколько, по их мнению, они могут выполнить в рамках установленной во времени продолжительности спринта. Когда спринт закончен, программное обеспечение должно работать и быть готовым к доставке, но это не обязательно означает, что оно будет доставлено; спринт не всегда приводит к выпуску, но Agile требует, чтобы программное обеспечение оставалось доступным для доставки.

### Бэклог

Создание бэклога - это роль владельца продукта. Это невыполненное задание состоит из всех функций программного обеспечения в порядке приоритетности. Функции в бэклоге являются результатом этапа требований и анализа и включают функции, которые не обязательно будут в немедленном выпуске. Новые функции могут быть добавлены в очередь в любое время, и владелец продукта может изменить приоритеты в очереди на основе отзывов клиентов.

### Истории пользователей

Когда функция приближается к началу списка приоритетов, она разбивается на более мелкие задачи, называемые пользовательскими историями. Каждая пользовательская история должна быть достаточно маленькой, чтобы одна команда могла завершить ее за один спринт. Если он слишком велик для выполнения за один спринт, команде следует разбить его дальше. Поскольку программное обеспечение должно поставляться в конце каждого спринта, пользовательская история также должна соответствовать этим правилам.

Пользовательская история - это простое изложение того, что нужно пользователю (или роли) и почему. Предлагаемый шаблон для пользовательской истории:

Как `<пользователь | роль>`, Я бы хотел `<действие>`, так что `<значение | выгода>`

Завершение пользовательской истории требует завершения всех этапов SDLC. Сама пользовательская история уже должна иметь требования, определенные владельцем продукта, и команде, которая занимается пользовательской историей, необходимо разработать дизайн для задачи, реализовать его и протестировать.

### Команды Scrum

Команды Scrum являются кросс-функциональными, коллективными, самоуправляемыми и самодостаточными. В идеале эти команды Scrum не должны быть больше 10 человек, но они должны быть достаточно большими, чтобы закончить пользовательскую историю за спринт.

Каждый день у каждой команды Scrum должен быть ежедневный стендап. Стендап - это встреча, которая должна длиться не более 15 минут и проходить в одно и то же время каждый день. Фактически, это называется «стенд-ап», потому что в идеале он должен быть достаточно коротким, чтобы команда смогла выполнить его без необходимости садиться.

Цель ежедневного стендапа - синхронизировать всех членов команды с тем, что каждый человек достиг с момента последнего стендапа, над чем они собираются работать до следующего стендапа, и какие препятствия могут мешать им закончить свою задачу. Скрам-мастер облегчает эти встречи, и их работа - сообщать и/или помогать устранять препятствия.

<!-- 3.1.10 -->
## Lean-разработка программного обеспечения

Lean-разработка программного обеспечения основана на принципах бережливого производства, которые направлены на минимизацию потерь и максимизацию ценности для клиента.

В своей простейшей форме экономичная разработка программного обеспечения обеспечивает только то, что хотят клиенты. В книге Lean Software Development: An Agile Toolkit есть семь принципов бережливого производства:

* Устранение отходов
* Улучшение обучения
* Решение как можно позже
* Доставка как можно быстрее
* Расширение возможностей команды
* Построение целостности
* Оптимизация всего

### Устранение отходов

Отходы - это все, что не увеличивает ценности для клиентов. Однако определение ценности субъективно, потому что определяется покупателем. Устранение отходов - это самый фундаментальный принцип бережливого производства, из которого вытекают все остальные принципы.

Чтобы устранить отходы, вы должны понимать, что такое отходы. Отходы - это все, что не приносит прямой ценности потребителю. Есть семь потерь при разработке программного обеспечения:

* Частично выполненная работа
* Дополнительные процессы
* Дополнительные функции
* Переключение задач
* Ожидание
* Движение
* Дефекты

### Частично сделанная работа

Частично выполненная работа является бесполезной, потому что:

* Это не добавляет ценности клиенту
* Время и ресурсы, потраченные на эту работу, можно было бы потратить на что-то, что представляет ценность для клиента.
* Работа обычно не обслуживается, поэтому со временем она устаревает.

### Дополнительные процессы

Дополнительные процессы похожи на кучу документов. В результате они являются пустой тратой почти по тем же причинам, что и частично выполненная работа.

### Дополнительные функции

Если покупатель не просил об этом, это не принесет им пользы. Это может быть неплохо, но лучше использовать ресурсы для создания именно того, что хотят клиенты.

### Переключение задач

Людям нужно время, чтобы переключить свое внимание на другую задачу, и это время, потраченное на переключение контекстов, - пустая трата. Переключение задач тратит впустую время ресурса (человека), поэтому назначать ресурс нескольким проектам - пустая трата.

### Ожидание

Многие согласятся, что ожидание по определению - большая трата времени. Так что любая задержка - бесполезная трата. Примеры задержек в разработке программного обеспечения:

* запуск проекта
* получение нужных ресурсов (персонала)
* получение требований от заказчика
* согласования документации
* получение ответов
* принимая решения
* реализация
* тестирование

### Движение

Бережливая разработка программного обеспечения определяет движение для двух вещей: людей и артефактов. Движение для людей - это когда людям нужно физически перейти от своего стола к другому члену команды, чтобы задать вопрос, сотрудничать и так далее. Когда они отходят от своего рабочего места, тратится не только время, необходимое им, чтобы добраться до места назначения, но и время переключения задач.

Движение артефактов - это когда документы или код перемещаются от одного человека к другому. В большинстве случаев документ не содержит всей информации для следующего человека, поэтому либо этот человек должен снова собрать информацию, либо передача требует времени, что является пустой тратой.

### Дефекты

Незаметные дефекты (также известные как ошибки) - это бесполезная трата из-за воздействия дефекта. Дефект может вызвать эффект снежного кома с другими функциями, поэтому время, необходимое для его отладки, является пустой тратой. Кроме того, для клиента ценность программного обеспечения снижается, когда у него возникают проблемы, поэтому функция оказывается бесполезной.

<!-- 3.1.11 -->
## Lean-разработка программного обеспечения (продолжение)

### Улучшение обучения с помощью коротких спринтов

Чтобы иметь возможность точно настраивать программное обеспечение, необходимо часто выполнять короткие итерации работающего программного обеспечения. Имея больше итераций:

* Разработчики учатся быстрее
* Клиенты могут оставить отзыв раньше
* Функции можно настроить так, чтобы они приносили клиентам больше пользы.

### Решайте как можно позже

Когда есть неопределенность, лучше отложить принятие решения как можно позже в процессе, потому что лучше основывать решения на фактах, а не на мнениях или предположениях.

Кроме того, когда решение еще не принято, программное обеспечение должно быть гибким, чтобы учесть неопределенность. Эта гибкость позволяет разработчикам вносить изменения при принятии решения - или в будущем, если требования изменятся.

### Доставить как можно быстрее

Быстрая доставка программного обеспечения:

* Позволяет клиентам оставлять отзывы
* Позволяет разработчикам усилить обучение
* Предоставляет клиентам функции, которые им нужны сейчас
* Не позволяет клиентам изменить свое мнение
* Заставляет всех принимать решения быстрее
* Производит меньше отходов

Вы заметите, что каждая из этих причин придерживается хотя бы одного из ранее обсуждавшихся принципов бережливого производства.

### Расширьте возможности команды

Каждый человек обладает собственными знаниями, поэтому позвольте им принимать решения в своей области знаний. В сочетании с другими принципами, такими как устранение потерь, принятие решений с опозданием и быстрая доставка, у других нет времени принимать решения за команду.

### Добросовестность

Целостность программного обеспечения - это когда программное обеспечение точно соответствует потребностям клиента. Другой уровень целостности заключается в том, что программное обеспечение сохраняет свою полезность для клиента.

### Оптимизировать в целом

Хотя одним из принципов является расширение прав и возможностей команды, каждый эксперт должен сделать шаг назад и увидеть общую картину. Программное обеспечение должно быть сплоченным. Ценность программного обеспечения пострадает, если каждый эксперт сосредоточится только на своем опыте и не учитывает последствия своих решений в отношении остальной части программного обеспечения.
