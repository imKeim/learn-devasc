<!-- 3.4.1 -->
## Методы, функции, модули и классы

Может показаться, что просто добавить код в файл и заставить его работать. Но по мере роста размера и сложности проекта и вовлечения других разработчиков (и заинтересованных сторон) требуются дисциплинированные методы и лучшие практики, чтобы помочь разработчикам писать лучший код и упростить совместную работу над ним.

Большинство разработчиков соглашаются с тем, что пытаются писать чистый код. Но что такое чистый код?

<!-- 3.4.2 -->
## Чистый код

Чистый код - это результат того, что разработчики пытаются сделать свой код легким для чтения и понимания для других разработчиков. Что представляет собой «чистый код» - это несколько субъективно, но вот несколько общих принципов:

* Является ли форматирование кода аккуратным и соответствует ли он общепринятым методам форматирования для задействованного (ых) компьютерного (ых) языка (ов) и/или отвечает ли конкретным требованиям институциональной, проектной и/или командной «книги стилей»?
* Он придерживается ВСЕХ вкладок или ВСЕХ пробелов?
* Используется ли во всем файле одинаковое количество табуляции или пробелов для каждого уровня отступа? (Некоторые языки, например Python, требуют этого.)
* Есть ли отступы в нужных местах?
* Используется ли согласованное форматирование для синтаксиса, например расположение фигурных скобок ({})?
* Являются ли имена переменных, объектов и других имен, используемых в коде, интуитивно понятными?
* Имеет ли смысл организованный код? Например, сгруппированы ли объявления с функциями вверху, основным кодом внизу или иначе, в зависимости от языка и контекста?
* Документирован ли код с соответствующими комментариями?
* Каждая строчка кода служит определенной цели? Вы удалили весь неиспользуемый код?
* Написан ли код таким образом, чтобы можно было повторно использовать общий код и чтобы весь код можно было легко протестировать на единицу?

Чистый код подчеркивает:

* стандартизированное форматирование и интуитивно понятное именование для удобства чтения, понимания и поиска
* общая организация, чтобы сообщить о намерениях и упростить поиск
* модульность для облегчения тестирования и повторного использования
* встроенные и другие комментарии
* другие характеристики, которые помогают сделать код самодокументированным
Теоретически другие разработчики должны иметь возможность понимать, использовать и изменять ваш код, не задавая вам вопросов. Это значительно ускоряет разработку, обеспечивая повторное использование, отладку, анализ безопасности, проверку кода и слияние, а также другие процессы. Это позволяет давним проектам (например, проектам с открытым исходным кодом) с большей уверенностью включать ваш код. И это позволяет организациям продолжать эффективно использовать ваш код после того, как вы перешли к другим проектам или работе.

Напротив, неочищенный код быстро становится техническим долгом. Он может быть неподдерживаемым или непригодным для использования с полной уверенностью. Это код, который необходимо реорганизовать или удалить и переписать, что дорого и требует много времени.

По каким еще причинам разработчики хотят писать чистый код?

1.	Чистый код легче понять, он более компактен и лучше организован, что обычно приводит к тому, что код работает правильно (меньше ошибок) и работает должным образом.
2.	Чистый код, будучи модульным, обычно легче тестировать с использованием автоматических методов, таких как фреймворки модульного тестирования.
3.	Чистый код, будучи стандартизированным, легче сканировать и проверять с помощью автоматических инструментов, таких как линтеры, или инструментов командной строки, таких как `grep`, `awk` и `sed`.
4.	Просто выглядит красивее.
Теперь, когда вы понимаете цели написания чистого кода, вы можете глубже погрузиться в передовые методы кодирования. В частности, мы рассмотрим, как разбить код на методы и функции, модули и классы.

<!-- 3.4.3 -->
## Методы и функции

Методы и функции разделяют ту же концепцию; они представляют собой блоки кода, которые при выполнении выполняют задачи. Если метод или функция не выполняется, эти задачи выполняться не будут. Хотя абсолютных правил не существует, вот несколько стандартных рекомендаций по определению того, следует ли инкапсулировать фрагмент кода (в метод или функцию):

* Код, выполняющий дискретную задачу, даже если это происходит только один раз, может быть кандидатом на инкапсуляцию. Классические примеры включают служебные функции, которые оценивают входные данные и возвращают логический результат (например, сравнивают две строки по длине), выполняют операции ввода-вывода (например, чтение файла с диска) или переводят данные в другие формы (например, анализировать и обрабатывать данные). В этом случае вы инкапсулируете для ясности и тестируемости, а также для возможного повторного использования или расширения в будущем.
* Код задачи, который используется более одного раза, вероятно, следует инкапсулировать. Если вы обнаружите, что копируете несколько строк кода, вероятно, это должен быть метод или функция. Вы можете учесть небольшие вариации в использовании, используя логику для оценки переданных параметров (см. ниже).

Самое важное в методах и функциях - это то, что их можно написать один раз и выполнять столько раз, сколько захотите. При правильном использовании методы и функции упростят ваш код и, следовательно, уменьшат вероятность ошибок.

Синтаксис функции в Python:

```python
# Определение функции
def functionName:
  ...блоки кода...
# Call the function
functionName()
```

### Аргументы и параметры

Еще одна особенность методов и функций - это возможность выполнять код на основе значений переменных, переданных при выполнении. Это так называемые аргументы. Чтобы использовать аргументы при вызове метода или функции, метод или функция должны быть написаны так, чтобы принимать эти переменные в качестве параметров.

Параметры могут быть любого типа данных, и каждый параметр в методе или функции может иметь свой тип данных. Аргументы, передаваемые методу или функции, должны соответствовать типу данных, ожидаемому для метода или функции.

В зависимости от языка кодирования, некоторые языки требуют, чтобы тип данных был определен в параметре (так называемые «строго типизированные» языки), в то время как некоторые позволяют это опционально.

Даже когда спецификация типа параметра не требуется, обычно это хорошая идея. Это упрощает повторное использование кода, потому что вам легче увидеть, какие параметры ожидает метод или функция. Это также делает сообщения об ошибках более понятными. Ошибки несоответствия типов легко исправить, тогда как неправильный тип, переданный в функцию, может вызвать ошибки, которые трудно понять на более глубоком уровне кода.

Параметры и аргументы добавляют гибкости методам и функциям. Иногда параметр является просто логическим флагом, который определяет, должны ли определенные строки кода выполняться в методе или функции. Думайте о параметрах как о входных данных для метода или функции.

Синтаксис функции с использованием аргументов и параметров в Python:

```python
# Определение функции
def functionName (параметр1, ..., параметрN):
  # Вы можете использовать параметры так же, как локальные переменные
  ... блоки кода ...
# Вызов функции
functionName ("аргумент1", 4, {"аргумент3": "3"})
```

В приведенном выше примере этой функции передается строка, целое число (или число) и объект, содержащий ключ и значение.

### Оператор `return`

Методы и функции выполняют задачи, а также могут возвращать значение. Во многих языках возвращаемое значение указывается с помощью ключевого слова `return`, за которым следует переменная или выражение. Это называется оператором возврата. Когда выполняется оператор `return`, возвращается значение оператора `return`, и любой код ниже него пропускается. Это задача строки кода, вызывающей метод или функцию, чтобы получить значение возврата, но это не обязательно.

Синтаксис функции с оператором `return` в Python:

```python
# Определение функции
def functionName (параметр1, ..., параметрN):
  # Вы можете использовать параметры так же, как локальные переменные
  ... блоки кода ...
  someVariable = параметр1 * параметр2
  return someVariable
# Вызов функции
myVariable = functionName ("аргумент1", 4, {"аргумент3": "3"})
```
В приведенном выше примере возвращаемое значение будет строкой «`аргумент1аргумент1аргумент1аргумент1`», потому что Python позволяет объединять строки с помощью оператора умножения.

### Пример функции

Допустим, ваш исходный код выглядит так:

```
# Вывести длину окружности для кругов радиусом 2, 5 и 7
radius1 = 2
radius2 = 5
radius3 = 7
# Формула окружности c = pi * диаметр
# Формула диаметра: d = 2 * радиус
pi = 3.14 # (В этом примере будет жестко закодировано pi)
circumference1 = pi * radius1 * 2
print ("Окружность круга с радиусом " + str (radius1) + " равна " + str (circumference1))
circumference2 = pi * radius2 * 2
print ("Окружность круга с радиусом " + str (radius2) + " равна " + str (circumference2))
circumference3 = pi * radius2 * 2
print ("Окружность круга с радиусом " + str (radius3) + " равна " + str (circumference3))
```

Как видите, здесь много повторяющегося кода.

Используя методы с параметрами, ваш код можно очистить:

```python
# Вывести длину окружности для кругов радиусом 2, 5 и 7
# В этом примере окружность и
# printCircumference - это имена
# функции. 'радиус' - параметр для
# функции и может использоваться в функции.
# Эта функция возвращает значение
# circleValue к коду, который вызвал
# функция.
def circumference(radius):
  # Формула окружности c = pi * диаметр
  # Формула диаметра: d = 2 * радиус
  pi = 3.14 # (В этом примере будет жестко закодировано pi)
  circumferenceValue = pi * radius * 2
  return circumferenceValue
def printCircumference (radius):
  myCircumference = circumference(radius)
  print ("("Окружность круга с радиусом " + str(radius) + " равна " + str(myCircumference))
radius1 = 2
radius2 = 5
radius3 = 7
# В следующей строке кода значение radius1 (2)
# - аргумент функции printCircumference
printCircumference (радиус1)
printCircumference (радиус2)
printCircumference (radius3)
```
Обратите внимание, что версия кода, использующая функции, параметры и аргументы, не приводит к дублированию кода. Кроме того, с помощью функций вы можете помечать блоки кода, что делает их назначение более понятным. Если бы этот пример был более сложным и в каждой функции было бы много строк кода, то трижды дублированные блоки кода в файле усложнили бы понимание.

### Методы и функции

Если методы и функции разделяют одну и ту же концепцию, почему они названы по-разному? Разница между методами и функциями состоит в том, что функции представляют собой отдельные блоки кода, а методы - блоки кода, связанные с объектом, как правило, для объектно-ориентированного программирования.

### Пример метода

Код из примера функции можно изменить, чтобы превратить функцию в метод с тем же результатом:

```python
# Вывести длину окружности для кругов радиусом 2, 5 и 7
# В этом примере есть класс с именем Circle.
# Классы будут обсуждаться позже. длина окружности
# и printCircumference - имена
# методов в классе. Эти методы возвращают
# значение circumferenceValue коду
# вызвавшему метод.
class Circle:
    def __init__(self, radius):
        self.radius = radius
    def circumference(self):
      # Формула окружности c = pi * диаметр
      # Формула диаметра: d = 2 * радиус
      pi = 3.14 # (В этом примере будет жестко закодировано pi)
      circumferenceValue = pi * self.radius * 2
      return circumferenceValue
    def printCircumference(self):
      myCircumference = self.circumference()
      print ("Длина окружности с радиусом " + str (self.radius) + " равна " + str (myCircumference))
radius1 = 2
radius2 = 5
radius3 = 7
# Поскольку Circle - это класс, он должен быть вызван
# сначала со значением радиуса.
circle1 = Circle(radius1)
# Поскольку printCircumference - это метод, он должен быть
# вызван с использованием синтаксиса [экземпляра класса].[метода]
# Просто вызов printCircumference() не работает
circle1.printCircumference()
circle2 = Circle(radius2)
circle2.printCircumference()
circle3 = Circle(radius3)
circle3.printCircumference()
```
<!-- -->
## 3.4.4 Модули

Модули - это способ создания независимых и автономных фрагментов кода, которые можно использовать повторно. Разработчики обычно используют модули для разделения большого проекта на более мелкие части. Таким образом, код легче читать и понимать, и каждый модуль можно разрабатывать параллельно без конфликтов. Модуль упакован в один файл. Помимо того, что он доступен для интеграции с другими модулями, он должен работать независимо.

Модуль состоит из набора функций и обычно содержит интерфейс для интеграции с другими модулями. По сути, это библиотека, и ее нельзя создать.

### Пример модуля

Ниже представлен модуль с набором функций, сохраненных в скрипте под названием `circleModule.py`. Вы снова увидите этот сценарий позже в лабораторной работе по этой теме.

```python
# Учитывая значение радиуса, вывести длину окружности.
# Формула для длины окружности: c = pi * 2 * radius

class Circle:

    def __init__(self, radius):
        self.radius = radius

    def circumference(self):
      pi = 3.14
      circumferenceValue = pi * self.radius * 2
      return circumferenceValue

    def printCircumference(self):
      myCircumference = self.circumference()
      print ("Длина о кружности с радиусом" + str (self.radius) + " равна " + str (myCircumference))
```
Приложение, которое существует в том же каталоге, что и circleModule.py мог использовать этот модуль, импортировав его, создав экземпляр класса, а затем используя точечную нотацию для вызова его функций, как показано ниже:

```python
from circleModule import Circle
 
# Первый экземпляр класса Circle.
circle1 = Circle(2)
# Вызвать printCircumference для экземпляра класса circle1.
circle1.printCircumference()

# Еще два экземпляра и вызов метода для класса Circle.
circle2 = Circle(5)
circle2.printCircumference()

circle3 = Circle(7)
circle3.printCircumference()
```
<!-- 3.4.5 -->
## Классы

Объектно-ориентированное программирование (ООП) в первоначальном виде основано на некоторых формально определенных свойствах: инкапсуляции, абстракции данных, полиморфизме и наследовании. В этом курсе, используя Python, вы сосредоточитесь на структурах классов Python как на одном из проявлений ООП.

В большинстве языков ООП и в Python классы являются средством объединения данных и функциональности. Каждое объявление класса определяет новый тип объекта.

Инкапсуляция функциональности вместе с хранением данных в единой структуре также обеспечивает один аспект абстракции данных. Функции, определенные в классе, называются методами класса. Классы могут иметь переменные класса и переменные объекта. По мере создания нового объекта класса создаются новые члены данных класса и члены данных объекта (переменные). Новые классы могут быть определены на основе существующих, ранее определенных классов, чтобы они унаследовали свойства, элементы данных и функциональные возможности (методы).

Как и в случае с другими структурами данных и переменными Python, объекты создаются (создаются) при первом использовании, а не заранее объявляются. Класс может быть создан (создан) несколько раз, и каждый со своими собственными значениями атрибутов данных, зависящих от объекта. (Классы Python также поддерживают переменные класса, которые являются общими для всех объектов класса.) Вне области имени класса ссылки на методы и атрибуты данных класса выполняются с использованием точечной нотации: [экземпляр класса]. [Имя метода].

Примечание: В отличие от других языков ООП, в Python нет средств для создания «частных» переменных класса или внутренних методов. Однако по соглашению методы и переменные с одним предшествующим подчеркиванием (_) считаются частными и не могут использоваться или ссылаться на них вне класса.

<!-- 3.4.6 -->
## Лабораторная работа - изучение классов Python

В этой лабораторной работе вы рассмотрите методы, функции и классы Python. Затем вы создаете класс и несколько раз инстанцируете его с разными значениями. Наконец, вы рассмотрите пример класса Circle, использованный в курсе.

Вы выполните следующие задачи:

* Часть 1. Запуск виртуальной машины DEVASC
* Часть 2: Функции, методы и классы обзора
* Часть 3: определение функции
* Часть 4: Определение класса с помощью методов
* Часть 5. Обзор скрипта circleClass.py
