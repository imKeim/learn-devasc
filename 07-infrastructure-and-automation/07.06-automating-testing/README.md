<!-- 7.6.1 -->
## Автоматизированное тестирование и проверка

В этом разделе вы узнаете о наборе продуктов и практик, созданных Cisco и ее сообществом пользователей для расширения автоматизации тестирования до программно-управляемой конфигурации сети, а также для уменьшения или устранения неопределенности в отношении того, как предполагаемые сетевые архитектуры будут функционировать и работать при полной реализации. .

### Проблемы инфраструктуры тестирования

Такие инструменты автоматизации, как Ansible, Puppet, Chef и другие, частично решают проблему, превращая инфраструктуру в код. Но DevOps обычно требует более детальных способов определения и реализации инфраструктур, удостоверения того, что развернутые инфраструктуры работают должным образом, и проактивного обеспечения бесперебойной работы. DevOps также нуждается в способах упреждающего принятия мер при неизбежных сбоях, а также поиска и устранения проблем при возникновении ошибок.

Когда вы используете инструменты модульного тестирования, такие как pytest, в тандеме с автоматизацией более высокого порядка и в сочетании с непрерывной доставкой (CI/CD), вы можете создавать среды, в которых код может быть автоматически протестирован при внесении изменений.

Фреймворки модульного тестирования делают тесты частью вашей кодовой базы, следуя коду через коммиты разработчика, запросы на вытягивание и выходы для проверки кода в QA/test и Production. Это особенно полезно в средах разработки, управляемой тестированием (TDD), где написание тестов - это непрерывный процесс, который фактически ведет разработку, автоматически обеспечивая очень высокий уровень покрытия тестами.

### Проблемы тестирования сети

Поведение и производительность реальной сети являются коллективными, поддерживаются конфигурациями множества отдельных единиц оборудования и программного обеспечения.

В традиционных средах подключение и функциональность поддерживаются вручную для множества отдельных единиц оборудования через различные интерфейсы. Часто операции требуют внесения изменений в работающее оборудование, передающее живой трафик. Это сложно, требует много времени, очень подвержено ошибкам и рискованно.

Неправильная конфигурация сети часто обнаруживается только косвенно, когда компьютеры не могут общаться друг с другом. По мере того, как сети становятся более сложными и переносят более разнообразный и зависимый от производительности трафик, риски для безопасности и снижения производительности, которые могут быть трудно обнаружить и количественно оценить, становятся все более важными последствиями неправильной конфигурации.

Управление сетью и тестирование по-прежнему остаются сложными, даже когда сетевые устройства и соединения становятся программно адресуемыми и виртуализированными. Способы построения и настройки сетей, безусловно, меняются, но вам все равно необходимо создать коллективную архитектуру для безопасного подключения, подробно касаясь многочисленных интерфейсов устройств.

### Тестирование программно определяемых сетей (SDN)

Cisco добилась огромных успехов в разработке программно-определяемых сетей (SDN) и промежуточного программного обеспечения, которые позволяют инженерам обращаться к коллективу физической сети как к единому программируемому объекту. В случае Cisco это включает:

* **Инфраструктура, ориентированная на приложения (ACI)** - Это комплексное решение для центра обработки данных, которое работает на базе Nexus 9000 и устройств с поддержкой APIC. Он обеспечивает абстракцию и программируемость всей сетевой функциональности с помощью контроллера инфраструктуры политики приложений (APIC).
* **Центр архитектуры цифровых сетей (Cisco DNA Center)** - Это открытая расширяемая программно-управляемая архитектура для Catalyst 9000 и других устройств IOSXE для корпоративной сети.
* REST API и SDK, обеспечивающие интеграцию с такими инструментами автоматизации, как Ansible, Puppet и Chef.

Такие решения, как ACI, управляют всей сетью с помощью конвергентных моделей (часто записываемых в декларативном синтаксисе YANG), которые представляют желаемые состояния функциональности и возможности подключения. Промежуточное ПО позволяет модели гармонично работать с другими моделями, которые в настоящее время определяют состояние системы и требования к ресурсам. Инженеры реже взаимодействуют с отдельными устройствами напрямую, хотя модели по-прежнему должны предоставлять достаточно деталей для настройки. Сложное, быстро развивающееся состояние крупных инфраструктур можно поддерживать в виде кода, что позволяет:

* Быстрое возвращение к желаемым состояниям при необходимости. Если устройство выходит из строя и заменяется, его можно быстро повторно интегрировать в существующую сеть и быстро восстановить его запрограммированную функциональность, а также поведение и производительность сети.
* Переносимость, так что при перемещении основного приложения из одного центра обработки данных в другой его необходимая сетевая конфигурация сопровождает его.
* Контроль версий, CI/CD и другие инструменты для поддержки, развития и применения сетевой кодовой базы.

Эти инновации становятся все более популярными среди более крупных организаций, операторов связи и других крупных организаций. Однако во многих случаях сети по-прежнему включают в себя несколько поколений разнообразных, гибридных, мультивендорных физических и виртуальных инфраструктур, поэтому проблема преднамеренной конфигурации на уровне устройств все еще вырисовывается.

И даже когда доступна сложная SDN, контроллеры/оркестраторы SDN не всегда могут предотвратить неправильную конфигурацию. Они могут отклонять ошибочный код, выполнять проверки работоспособности перед применением изменений и сообщать, когда модели требуют превышения пороговых значений ресурсов, но, казалось бы, законные изменения все еще могут применяться.

### Решение для тестирования сети: pyATS

Python Automated Test System (pyATS) - это основанное на Python решение для тестирования и проверки сетевых устройств, изначально разработанное Cisco для внутреннего использования, затем сделанное общедоступным и частично с открытым исходным кодом. pyATS можно использовать, чтобы проверить, работают ли ваши изменения перед их вводом в производство, а также продолжить проверку и мониторинг в производственной среде, чтобы обеспечить бесперебойную работу.

### Экология pyATS

pyATS возник как низкоуровневый Python для всей тестовой системы. Его библиотечная система более высокого уровня Genie предоставляет необходимые API-интерфейсы и библиотеки, которые управляют сетевыми устройствами и взаимодействуют с ними, а также выполняют фактическое тестирование. Вместе они образуют тестовое решение Cisco, известное как pyATS.

pyATS имеет несколько ключевых функций:

* Фреймворк и библиотеки pyATS можно использовать в любом коде Python.
* Он модульный и включает в себя такие компоненты, как:
* AEtest выполняет тестовые сценарии.
* Easypy - это среда выполнения, которая обеспечивает параллельное выполнение нескольких сценариев, собирает журналы в одном месте и обеспечивает центральную точку для внесения изменений в тестируемую топологию.
* Интерфейс командной строки позволяет быстро опрашивать действующие сети, извлекать факты и помогает автоматизировать выполнение тестовых сценариев и других криминалистических исследований. Это обеспечивает очень быструю отладку «без кода» и исправление проблем в сетевых топологиях, созданных и поддерживаемых с помощью этих инструментов.

В средах SDN/облачных/виртуальных сетей установка может включать фактическое построение топологии, а очистка может включать ее удаление, освобождая ресурсы платформы. Эту настройку и очистку можно выполнить напрямую с помощью кода pyATS. pyATS предоставляет огромную библиотеку интерфейсов для Cisco и другой инфраструктуры через ряд интерфейсов, включая низкоуровневые интерфейсы командной строки и REST API, а также соединители с ACI и другими структурами управления SDN более высокого порядка.

pyATS может использовать, анализировать и реализовывать топологии, описанные в JSON, как модели YANG, а также из других источников, даже из электронных таблиц Excel.

pyATS также может быть интегрирован с инструментами автоматизации, такими как Ansible, для создания, предоставления и удаления. Однако, возможно, лучше поступить наоборот. Используйте Ansible, Puppet или Chef для управления всей кодовой базой инфраструктуры и пусть эти продукты вызывают Python (и pyATS) для обработки деталей реализации сети. Эти инструменты также используют ACI или другое промежуточное программное обеспечение для упрощения задачи и позволяют раздельное хранение и управление версиями YANG или других моделей, определяющих конкретные топологии.

Кроме того, вы можете вызывать pyATS косвенно несколькими способами (включая способы, требующие минимальных знаний в области программирования Python).

<!-- 7.6.2 -->
## Пример pyATS

Следующее содержимое показывает, как использовать pyATS для создания и применения тестов. Вам необходимо будет ознакомиться с этой информацией, чтобы выполнить лабораторную работу на следующей странице. Просто прочтите этот пример, чтобы лучше понять pyATS.

### Виртуальные среды

Инструмент pyATS лучше всего устанавливать для личной работы в виртуальной среде Python (venv). Venv - это среда, скопированная из вашей базовой среды, но хранимая отдельно от нее. Это позволяет избежать установки программного обеспечения, которое может навсегда изменить состояние вашей системы. Виртуальные среды существуют в папках в вашей файловой системе. После создания они могут быть активированы, настроены по желанию, а установленные в них компоненты могут быть обновлены или изменены без отражения изменений в конфигурации вашего хоста. Возможность создания виртуальных сред встроена в Python 3, но Ubuntu 18.04 может потребовать от вас установки `python3-venv` пакет отдельно.

Следующие инструкции описывают, как создать venv в Ubuntu 18.04 (где `python3` это команда по умолчанию). Если вы используете другую операционную систему, обратитесь к соответствующей документации для pip и виртуальных сред.

Гарантировать, что `python3-pip`, менеджер пакетов Python3. Вы также должны установить `git`, который вам понадобится позже:

```
sudo apt-get install python3-pip
sudo apt-get install python3-venv
sudo apt-get install git
```

Создайте новую виртуальную среду в выбранном вами каталоге. В этом примере он называется `myproject`.

```
python3 -m venv myproject
```

Venv создает указанный рабочий каталог (`myproject`) и соответствующая структура папок, содержащая вспомогательные функции и артефакты, описывающие конфигурацию этой среды. На этом этапе вы можете перейти к `myproject` папку и активируйте venv:

```
cd myproject
source bin/activate
```

### Установка PYATS

Вы можете установить pyATS из общедоступного репозитория пакетов Pip (PyPI).

> **Примечание**: Вы можете увидеть ошибку " Failed building wheel for... `<wheelname>`" при установке pyATS через pip. Вы можете спокойно игнорировать эти ошибки как `pip` имеет план резервного копирования на случай этих сбоев, и зависимости установлены, несмотря на сообщения об ошибках.

```
pip install pyats[full]
```

Убедитесь, что он был установлен, перечислив справку:

```
pyats --help
```

Клонируйте репозиторий примеров скриптов pyATS, поддерживаемый Cisco DevNet, который содержит образцы файлов, которые вы можете изучить:

```
git clone https://github.com/CiscoDevNet/pyats-sample-scripts.git
cd pyats-sample-scripts
```

Установленная цель, `pyats[full]`, включает как низкоуровневую основу, различные компоненты, зависимости, так и высокоуровневые библиотеки Genie.

### синтаксис тестового примера pyATS

Синтаксис объявления теста для pyATS вдохновлен синтаксисом популярных фреймворков модульного тестирования Python, таких как `pytest`. Он поддерживает базовые операторы тестирования, такие как утверждение, что переменная имеет заданное значение, и добавляет к этому возможность явно предоставлять результаты (включая причину результата и данные) через определенные API. Это демонстрируется в следующем отрывке из основного тестового сценария. Сценарий тестирования pyATS можно найти в `/basics/pyats-sample-script.py` из репозитория, который вы клонировали ранее. Часть сценария показана ниже.

```
class MyTestcase(aetest.Testcase):
    @aetest.setup
    def setup(self, section):
        '''setup section
        create a setup section by defining a method and decorating it with
        @aetest.setup decorator. The method should be named 'setup' as good
        convention.
        setup sections are optional within a testcase, and is always runs first.
        '''
        log.info("%s testcase setup/preparation" % self.uid)
        # set some variables
        self.a = 1
        self.b = 2
    @aetest.test
    def test_1(self, section):
        '''test section
        create a test section by defining a method and decorating it with
        @aetest.test decorator. The name of the method becomes the unique id
        labelling this test. There may be arbitrary number of tests within a
        testcase.
        test sections run in the order they appear within a testcase body.
        '''
        log.info("test section: %s in testcase %s" % (section.uid, self.uid))
        # testcase instance is preserved, eg
        assert self.a == 1
    @aetest.test
    def test_2(self, section):
        '''
        you can also provide explicit results, reason and data using result API.
        These information will be captured in the result summary.
        '''
        log.info("test section: %s in testcase %s" % (section.uid, self.uid))
        if self.b == 2:
            self.passed('variable b contains the expected value',
                        data = {'b': self.b})
        else:
            self.failed('variable b did not contains the expected value',
                        data = {'b': self.b})
```

Если вы щелкните и изучите весь тестовый скрипт, вы увидите, что он содержит несколько разделов:

* Общий блок настройки
* Множественные блоки тестирования
* Общий блок очистки

Эти блоки содержат операторы, которые подготавливают и/или определяют готовность тестовой топологии (процесс, который может включать внедрение проблемы), выполняют тесты, а затем возвращают топологию в известное состояние.

Каждый из блоков тестирования, которые в документации pyATS часто называют тестовыми примерами, может содержать несколько тестов со своим собственным кодом настройки и очистки. Лучшая практика предполагает, что общий раздел «Очистка» в конце должен быть разработан для идемпотентности. Это означает, что он должен проверять и восстанавливать все изменения, внесенные в программу установки и тестирования, восстанавливая топологию в исходное желаемое состояние.

### Скрипты и задания pyATS

Скрипт pyATS - это файл Python, в котором объявлены тесты pyATS. Его можно запускать напрямую как отдельный файл сценария Python, генерируя вывод только в окно вашего терминала. В качестве альтернативы, один или несколько скриптов pyATS могут быть скомпилированы в «задание» и запускаться вместе как пакет с помощью модуля pyATS EasyPy. Это позволяет выполнять параллельное выполнение нескольких сценариев, собирать журналы в одном месте и обеспечивает центральную точку для внесения изменений в тестируемую топологию.

Файл задания pyATS можно найти в `/basics/pyats-sample-job.py` в репозитории, который вы клонировали ранее. Часть файла проекта показана ниже.

```python
import os
from pyats.easypy import run
def main():
    '''
    main() function is the default pyATS job file entry point that Easypy module consumes
    '''
    # find the location of the script in relation to the job file
    script_path = os.path.dirname(os.path.abspath(__file__))
    testscript = os.path.join(script_path, 'basic_example_script.py')
    # execute the test script
    run(testscript=testscript)
```
Если вы выполнили шаги установки и теперь находитесь в виртуальной среде, содержащей клонированное репо, вы можете запустить это задание вручную, чтобы вызвать базовый тестовый пример:

```
pyats run job basic/basic_example_job.py
```

Если вы видите ошибку вроде `RuntimeError: Jobfile 'basic_example_script' did not define main()`, это означает, что вы выполнили файл `basic_example_script.py`, а не `basic_example_job.py`. Или, если вы видите `The provided jobfile 'pyats-sample-scripts/basic/basic_example_job.py' does not exist.` дважды проверьте, в каком каталоге вы работаете. Возможно, вы уже поменяли каталоги на `pyats-sample-scripts` каталог репозитория.

```
Output
2020-03-01T12:38:50: %EASYPY-INFO: Starting job run: basic_example_job 2020-03-01T12:38:50: %EASYPY-INFO: Runinfo directory: /Users/agentle/.pyats/runinfo/basic_example_job.2020Mar01_12:38:48.974991 2020-03-01T12:38:50: %EASYPY-INFO: -------------------------------------------------------------------------------- 2020-03-01T12:38:51: %EASYPY-INFO: Starting task execution: Task-1 2020-03-01T12:38:51: %EASYPY-INFO:     test harness = pyats.aetest 2020-03-01T12:38:51: %EASYPY-INFO:     testscript   = /Users/agentle/src/pyats-sample-scripts/basic/basic_example_script.py 2020-03-01T12:38:51: %AETEST-INFO: +------------------------------------------------------------------------------+ 2020-03-01T12:38:51: %AETEST-INFO: |                            Starting common setup                             | 2020-03-01T12:38:51: %AETEST-INFO: +------------------------------------------------------------------------------+ 2020-03-01T12:38:51: %AETEST-INFO: +------------------------------------------------------------------------------+ 2020-03-01T12:38:51: %AETEST-INFO: |                       Starting subsection subsection_1                       | 2020-03-01T12:38:51: %AETEST-INFO: +------------------------------------------------------------------------------+ 2020-03-01T12:38:51: %SCRIPT-INFO: hello world! 2020-03-01T12:38:51: %AETEST-INFO: The result of subsection subsection_1 is => PASSED 2020-03-01T12:38:51: %AETEST-INFO: +------------------------------------------------------------------------------+ 2020-03-01T12:38:51: %AETEST-INFO: |                       Starting subsection subsection_2                       | 2020-03-01T12:38:51: %AETEST-INFO: +------------------------------------------------------------------------------+ 2020-03-01T12:38:51: %SCRIPT-INFO: inside subsection subsection_2 2020-03-01T12:38:51: %AETEST-INFO: The result of subsection subsection_2 is => PASSED 2020-03-01T12:38:51: %AETEST-INFO: The result of common setup is => PASSED 2020-03-01T12:38:51: %AETEST-INFO: +------------------------------------------------------------------------------+ 2020-03-01T12:38:51: %AETEST-INFO: |                        Starting testcase Testcase_One                        | 2020-03-01T12:38:51: %AETEST-INFO: +------------------------------------------------------------------------------+ 2020-03-01T12:38:51: %AETEST-INFO: +------------------------------------------------------------------------------+ 2020-03-01T12:38:51: %AETEST-INFO: |                            Starting section setup                            | 2020-03-01T12:38:51: %AETEST-INFO: +------------------------------------------------------------------------------+ 2020-03-01T12:38:51: %SCRIPT-INFO: Testcase_One testcase setup/preparation 2020-03-01T12:38:51: %AETEST-INFO: The result of section setup is => PASSED 2020-03-01T12:38:51: %AETEST-INFO: +------------------------------------------------------------------------------+ 2020-03-01T12:38:51: %AETEST-INFO: |                           Starting section test_1                            | 2020-03-01T12:38:51: %AETEST-INFO: +------------------------------------------------------------------------------+ 2020-03-01T12:38:51: %SCRIPT-INFO: test section: test_1 in testcase Testcase_One 2020-03-01T12:38:51: %AETEST-INFO: The result of section test_1 is => PASSED 2020-03-01T12:38:51: %AETEST-INFO: +------------------------------------------------------------------------------+ 2020-03-01T12:38:51: %AETEST-INFO: |                           Starting section test_2                            | 2020-03-01T12:38:51: %AETEST-INFO: +------------------------------------------------------------------------------+ 2020-03-01T12:38:51: %SCRIPT-INFO: test section: test_2 in testcase Testcase_One 2020-03-01T12:38:51: %AETEST-INFO: Passed reason: variable b contains the expected value 2020-03-01T12:38:51: %AETEST-INFO: The result of section test_2 is => PASSED 2020-03-01T12:38:51: %AETEST-INFO: +------------------------------------------------------------------------------+ 2020-03-01T12:38:51: %AETEST-INFO: |                           Starting section cleanup                           | 2020-03-01T12:38:51: %AETEST-INFO: +------------------------------------------------------------------------------+ 2020-03-01T12:38:51: %SCRIPT-INFO: Testcase_One testcase cleanup/teardown 2020-03-01T12:38:51: %AETEST-INFO: The result of section cleanup is => PASSED 2020-03-01T12:38:51: %AETEST-INFO: The result of testcase Testcase_One is => PASSED 2020-03-01T12:38:51: %AETEST-INFO: +------------------------------------------------------------------------------+ 2020-03-01T12:38:51: %AETEST-INFO: |                           Starting common cleanup                            | 2020-03-01T12:38:51: %AETEST-INFO: +------------------------------------------------------------------------------+ 2020-03-01T12:38:51: %AETEST-INFO: +------------------------------------------------------------------------------+ 2020-03-01T12:38:51: %AETEST-INFO: |                     Starting subsection clean_everything                     | 2020-03-01T12:38:51: %AETEST-INFO: +------------------------------------------------------------------------------+ 2020-03-01T12:38:51: %SCRIPT-INFO: goodbye world 2020-03-01T12:38:51: %AETEST-INFO: The result of subsection clean_everything is => PASSED 2020-03-01T12:38:51: %AETEST-INFO: The result of common cleanup is => PASSED 2020-03-01T12:38:51: %EASYPY-INFO: -------------------------------------------------------------------------------- 2020-03-01T12:38:51: %EASYPY-INFO: Job finished. Wrapping up... 2020-03-01T12:38:52: %EASYPY-INFO: Creating archive file: /Users/agentle/.pyats/archive/20-Mar/basic_example_job.2020Mar01_12:38:48.974991.zip 2020-03-01T12:38:52: %EASYPY-INFO: +------------------------------------------------------------------------------+ 2020-03-01T12:38:52: %EASYPY-INFO: |                                Easypy Report                                 | 2020-03-01T12:38:52: %EASYPY-INFO: +------------------------------------------------------------------------------+ 2020-03-01T12:38:52: %EASYPY-INFO: pyATS Instance   : /Users/agentle/.local/share/virtualenvs/pyats-sample-scripts-b4vw68FQ/bin/.. 2020-03-01T12:38:52: %EASYPY-INFO: Python Version   : cpython-3.8.1 (64bit) 2020-03-01T12:38:52: %EASYPY-INFO: CLI Arguments    : /Users/agentle/.local/share/virtualenvs/pyats-sample-scripts-b4vw68FQ/bin/pyats run job basic/basic_example_job.py 2020-03-01T12:38:52: %EASYPY-INFO: User             : agentle 2020-03-01T12:38:52: %EASYPY-INFO: Host Server      : AGENTLE-M-339A 2020-03-01T12:38:52: %EASYPY-INFO: Host OS Version  : Mac OSX 10.14.6 (x86_64) 2020-03-01T12:38:52: %EASYPY-INFO: 2020-03-01T12:38:52: %EASYPY-INFO: Job Information 2020-03-01T12:38:52: %EASYPY-INFO:     Name         : basic_example_job 2020-03-01T12:38:52: %EASYPY-INFO:     Start time   : 2020-03-01 12:38:50.019013 2020-03-01T12:38:52: %EASYPY-INFO:     Stop time    : 2020-03-01 12:38:51.732162 2020-03-01T12:38:52: %EASYPY-INFO:     Elapsed time : 0:00:01.713149 2020-03-01T12:38:52: %EASYPY-INFO:     Archive      : /Users/agentle/.pyats/archive/20-Mar/basic_example_job.2020Mar01_12:38:48.974991.zip 2020-03-01T12:38:52: %EASYPY-INFO: 2020-03-01T12:38:52: %EASYPY-INFO: Total Tasks    : 1 2020-03-01T12:38:52: %EASYPY-INFO: 2020-03-01T12:38:52: %EASYPY-INFO: Overall Stats 2020-03-01T12:38:52: %EASYPY-INFO:     Passed     : 3 2020-03-01T12:38:52: %EASYPY-INFO:     Passx      : 0 2020-03-01T12:38:52: %EASYPY-INFO:     Failed     : 0 2020-03-01T12:38:52: %EASYPY-INFO:     Aborted    : 0 2020-03-01T12:38:52: %EASYPY-INFO:     Blocked    : 0 2020-03-01T12:38:52: %EASYPY-INFO:     Skipped    : 0 2020-03-01T12:38:52: %EASYPY-INFO:     Errored    : 0 2020-03-01T12:38:52: %EASYPY-INFO: 2020-03-01T12:38:52: %EASYPY-INFO:     TOTAL      : 3 2020-03-01T12:38:52: %EASYPY-INFO: 2020-03-01T12:38:52: %EASYPY-INFO: Success Rate   : 100.00 % 2020-03-01T12:38:52: %EASYPY-INFO: 2020-03-01T12:38:52: %EASYPY-INFO: +------------------------------------------------------------------------------+ 2020-03-01T12:38:52: %EASYPY-INFO: |                             Task Result Summary                              | 2020-03-01T12:38:52: %EASYPY-INFO: +------------------------------------------------------------------------------+ 2020-03-01T12:38:52: %EASYPY-INFO: Task-1: basic_example_script.common_setup                                 PASSED 2020-03-01T12:38:52: %EASYPY-INFO: Task-1: basic_example_script.Testcase_One                                 PASSED 2020-03-01T12:38:52: %EASYPY-INFO: Task-1: basic_example_script.common_cleanup                               PASSED 2020-03-01T12:38:52: %EASYPY-INFO: 2020-03-01T12:38:52: %EASYPY-INFO: +------------------------------------------------------------------------------+ 2020-03-01T12:38:52: %EASYPY-INFO: |                             Task Result Details                              | 2020-03-01T12:38:52: %EASYPY-INFO: +------------------------------------------------------------------------------+ 2020-03-01T12:38:52: %EASYPY-INFO: Task-1: basic_example_script 2020-03-01T12:38:52: %EASYPY-INFO: |-- common_setup                                                          PASSED 2020-03-01T12:38:52: %EASYPY-INFO: |   |-- subsection_1                                                      PASSED 2020-03-01T12:38:52: %EASYPY-INFO: |   -- subsection_2                                                      PASSED 2020-03-01T12:38:52: %EASYPY-INFO: |-- Testcase_One                                                          PASSED 2020-03-01T12:38:52: %EASYPY-INFO: |   |-- setup                                                             PASSED 2020-03-01T12:38:52: %EASYPY-INFO: |   |-- test_1                                                            PASSED 2020-03-01T12:38:52: %EASYPY-INFO: |   |-- test_2                                                            PASSED 2020-03-01T12:38:52: %EASYPY-INFO: |   -- cleanup                                                           PASSED 2020-03-01T12:38:52: %EASYPY-INFO: -- common_cleanup                                                        PASSED 2020-03-01T12:38:52: %EASYPY-INFO:     -- clean_everything                                                  PASSED 2020-03-01T12:38:52: %EASYPY-INFO: Sending report email... 2020-03-01T12:38:52: %EASYPY-INFO: Missing SMTP server configuration, or failed to reach/authenticate/send mail. Result notification email failed to send. 2020-03-01T12:38:52: %EASYPY-INFO: Done!
```

### Совет профессионала

Используйте следующую команду для просмотра журналов локально: просмотр журналов pyats. Эта команда автоматически открывает страницу в вашем веб-браузере, отображающую результаты теста pyATS в формате графического интерфейса пользователя.

```
pyats logs view
```

Это очень простой пример, в котором используются самые основные функции pyATS. Фактической топологии или испытательного стенда, на котором можно было бы запускать тесты сетевого типа, нет. Тем не менее, в выходных данных показан вид подробного журнала тестов, который создает команда pyATS, включая журнал выполнения всего процесса по разделам, от установки до разборки, и добавленные подробные разделы отчета:

```
2020-03-01T12:38:52: %EASYPY-INFO: +------------------------------------------------------------------------------+
2020-03-01T12:38:52: %EASYPY-INFO: |                             Task Result Summary                              |
2020-03-01T12:38:52: %EASYPY-INFO: +------------------------------------------------------------------------------+
2020-03-01T12:38:52: %EASYPY-INFO: Task-1: basic_example_script.common_setup                                 PASSED
2020-03-01T12:38:52: %EASYPY-INFO: Task-1: basic_example_script.Testcase_One                                 PASSED
2020-03-01T12:38:52: %EASYPY-INFO: Task-1: basic_example_script.common_cleanup                               PASSED
```

При каждом запуске задания создается архив `.zip`, который по умолчанию хранится в домашнем каталоге вашего пользователя `~/.pyats/archive`. Вы можете перечислить файлы и разархивировать каждый архивный файл, чтобы просмотреть их содержимое (в виде обычных текстовых файлов), или использовать встроенную программу просмотра журналов на основе веб-браузера, используя локальный веб-сервер:

```
pyats logs list
pyats logs view
```

### файл тестовой системы pyATS

Стенд может быть одним файлом YAML или может быть программно собран из файлов YAML (установление базовой структуры) и файлов Python, которые используют модули библиотеки pyATS (и, возможно, Genie) для:

* Определите тестовые устройства (маршрутизаторы, коммутаторы, серверы и т. Д.), Подсистемы (например, порты, сетевые карты) и их взаимосвязи.
* Установите с ними управленческие связи, используя PYATS. `ConnectionManager` класс для создания связей и работы с ними. Внутри модели топологии pyATS устройства создаются как объекты, которые включают `connectionmanager` атрибут, содержащий экземпляр `ConnectionManager` класс, который управляет активными подключениями к реальному устройству.

Файл тестового стенда является важным вкладом в остальную часть библиотеки и экосистемы pyATS. Он предоставляет инфраструктуре информацию для загрузки нужного набора библиотечных API (например, парсеров) для каждого устройства и того, как эффективно с ними общаться.

Настоящие файлы тестовых стендов для больших топологий могут быть длинными, глубоко вложенными и сложными. Простой файл `testbed.yaml` с одним устройством, идентифицированным с `<device_ip>` ниже может выглядеть этот пример. Чтобы запустить пример, вам нужно будет ввести реальный IP-адрес для устройства, которое соответствует `type`  а также `os`  настройки.

> **Примечание**: Это пример, и он не будет работать с pyATS, если вы не введете реальные значения для имени пользователя, пароля и IP-адреса подключения.

```
devices:
  router1:
    type: router
    os: nxos
    platform: n9kv
    alias: under_test
    credentials:
      default:
        username: "%ENV{MY_USERNAME}"
        password: "%ENV{MY_PASSWORD}"
    connections:
        cli:
            protocol: ssh
            ip: "<device_ip>"
```

В этом примере определяется маршрутизатор с именем хоста `router1`, с поддерживаемой ОС.

* '`platform`' рекомендуется и определяется как имя компьютера (например, UUID виртуальной машины), на котором выполняется компонент.
* Этот файл предоставляет учетные данные по умолчанию для входа в устройство, полученные из переменных, установленных в вашей локальной среде (например, `export MY_USERNAME=username`).
* Файл определяет метод подключения и протокол, используемые для управления устройством, а также его IP-адрес. pyATS в настоящее время общается через Telnet, SSH, REST, RESTCONF (YANG) и NETCONF (YANG).

Чтобы убедиться, что YAML-файл вашей тестовой системы соответствует требованиям pyATS (и соответствует стандартной схеме), замените `username`, `password`, а также значение `ip`, а затем запустите команду `pyats validate` так:

```
pyats validate testbed testbed.yaml
```

Эта команда проверяет содержимое вашего файла, загружает его и отображает все ошибки в схеме или формате.

> **Примечание**: Можно использовать библиотеки pyATS без ввода файла тестового стола, где вы можете выбрать программное определение устройств, соединений и других элементов тестового стола.

### Библиотека pyATS: Genie

Genie - это библиотечная система верхнего уровня pyATS, которая предоставляет API-интерфейсы для взаимодействия с устройствами, а также мощный интерфейс командной строки для топологии, управления устройствами и опроса.

После установки он добавляет свои функции и возможности в структуру pyATS.

Например, Genie предлагает парсеры для широкого спектра сетевых операционных систем и инфраструктуры. Парсеры - это API-интерфейсы, которые преобразуют вывод устройства в структурированные данные Python. Для тестирования парсеров войдите в интерактивную оболочку pyATS. По сути, это то же самое, что и интерпретатор/интерактивная оболочка Python, за исключением того, что он предоставляет нишевые функции, такие как автоматическая загрузка файла тестовой системы:

```
pyats shell --testbed-file testbed.yaml
Welcome to pyATS Interactive Shell
==================================
Python 3.6.9 (default, Nov 11 2019, 12:11:42)
[GCC 4.2.1 Compatible Apple LLVM 11.0.0 (clang-1100.0.33.12)]
>>> from pyats.topology import loader
>>> testbed = loader.load('testbed.yaml')
*------------------------------------------------------------------------------
>>>
```

> **Примечание**: Если вы используете версию pyATS старше v20.1, эквивалентная команда `genie shell`.

Теперь вы можете получить доступ к устройствам загруженного тестового стенда, установить соединение и проанализировать выходные данные команд устройства следующим образом:

```
# connect to testbed devices in parallel
testbed.connect()
# parse device output from your "router1"
testbed.devices['router1'].parse('show interfaces')
```

API `Device.parse()` возвращает обработанные структурированные данные (словарь Python), позволяя вам создавать свою собственную бизнес-логику и/или тесты поверх. Чтобы увидеть список всех доступных платформ и поддерживаемых команд парсера в библиотеке Genie, посетите Доступные парсеры в документации Genie.

Кроме того, можно также использовать функциональные возможности библиотеки через интерфейс командной строки оболочки (`pyats` команды). Вы можете интерактивно извлечь исчерпывающее текстовое описание конфигурации и рабочих состояний различных протоколов, функций и информации об оборудовании в данной топологии. Например:

```
pyats learn conf --testbed-file testbed.yaml --output my_network
```

Базовый механизм Genie подключается параллельно ко всем устройствам, определенным на стенде, и собирает их конфигурации (`conf`) в удобочитаемом файле (в данном случае с именем `my_network`). Выходные данные предоставляют подробную информацию о состоянии сети, включая настройку интерфейса, VLAN, конфигурацию связующего дерева и многие другие функции.

Теперь, когда выходной файл существует, он служит «золотым стандартом» для конфигурации этой топологии. В любой последующий момент времени, если кажется, что дрейф конфигурации произошел и что-то сломалось, вы можете снова запустить Genie:

```
pyats learn conf --testbed-file testbed.yaml --output my_broken_network
```

Команда `diff` сравнивает конфигурации, быстро обнаруживая различия.

```
pyats diff my_network my_broken_network
```

Этот API возвращает набор файлов различий, детализируя любые изменения и позволяя быстро обнаружить причину проблем.

Чтобы увидеть список «функций», которые в настоящее время поддерживает Genie pyATS (и которые можно изучить), см. Доступные модели в документации Genie.

Многие функции pyATS, такие как `parse` а также `parse`, могут быть реализованы непосредственно в Python (либо с помощью интерактивной оболочки, либо в ваших файлах сценария .py, предназначенных для программистов), а также через интерфейс командной строки (для непрограммистов). Вы можете узнать больше об этой теме в Руководстве по началу работы с pyATS.

### Собираем все вместе

В этом разделе содержится краткое введение в pyATS и сопутствующие решения. В следующей теме представлен VIRL, инструмент Cisco для точного моделирования сетей на серверной платформе, а также некоторые связанные с ним утилиты.

> **Примечание**: Платформы Windows еще не поддерживаются для использования pyATS.
